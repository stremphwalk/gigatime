[
  {
    "projectId": "36533163-cb6a-4961-848c-92c17e4210eb",
    "testId": "2fd3f0d9-08d2-4d84-a418-e64c8d737ed0",
    "userId": "04680408-90a1-7095-fc0d-c2c13611246e",
    "title": "TC001-verify_user_profile_initialization",
    "description": "Test the /api/init-user endpoint to ensure that user profiles are initialized correctly with proper authentication and that the response confirms successful initialization.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5002\"\nTIMEOUT = 30\n\ndef test_verify_user_profile_initialization():\n    url = f\"{BASE_URL}/api/init-user\"\n    dummy_token = \"Bearer dummy-valid-token-for-testing\"  # Should be replaced with a valid token if available\n\n    headers_with_auth = {\n        \"Authorization\": dummy_token,\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Test unauthorized access (no token)\n    try:\n        response = requests.post(url, timeout=TIMEOUT)\n    except Exception as e:\n        assert False, f\"Request to {url} failed without auth: {e}\"\n    assert response.status_code in (200, 401, 403), f\"Expected 401, 403 or 200 without auth, got {response.status_code}\"\n\n    # Test authorized access\n    try:\n        response = requests.post(url, headers=headers_with_auth, timeout=TIMEOUT)\n    except Exception as e:\n        assert False, f\"Request to {url} failed with auth: {e}\"\n    assert response.status_code == 200, f\"Expected 200 OK with auth, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except Exception:\n        data = None\n    if data is not None:\n        assert isinstance(data, dict), \"Response JSON is not a dictionary\"\n\n\ntest_verify_user_profile_initialization()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-10T19:02:56.468Z",
    "modified": "2025-09-10T19:04:32.828Z"
  },
  {
    "projectId": "36533163-cb6a-4961-848c-92c17e4210eb",
    "testId": "fd739a31-4dc3-4ca4-8d2b-dd1df31770f3",
    "userId": "04680408-90a1-7095-fc0d-c2c13611246e",
    "title": "TC002-verify_medical_notes_crud_operations",
    "description": "Test the /api/notes endpoint for creating, retrieving, updating, and deleting medical notes, ensuring proper authentication, data validation, and correct response handling.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5002\"\nTIMEOUT = 30\n\n# Simulated helper function for obtaining an auth token (adjust as needed)\ndef get_auth_token():\n    # For testing purposes, assume an environment variable or a fixed token is used\n    # Replace this with actual auth flow if available\n    return \"Bearer testauthtoken1234567890abcdef\"\n\ndef test_verify_medical_notes_crud_operations():\n    headers = {\n        \"Authorization\": get_auth_token(),\n        \"Content-Type\": \"application/json\"\n    }\n\n    note_id = None\n    try:\n        # 1. Create a new medical note\n        create_payload = {\n            \"title\": \"Test Note \" + str(uuid.uuid4()),\n            \"patientName\": \"John Doe\",\n            \"content\": {\n                \"subjective\": \"Patient complains of headache.\",\n                \"objective\": \"Blood pressure normal.\",\n                \"assessment\": \"Tension headache.\",\n                \"plan\": \"Rest and hydration.\"\n            }\n        }\n        create_response = requests.post(\n            f\"{BASE_URL}/api/notes\",\n            json=create_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert create_response.status_code == 201 or create_response.status_code == 200, f\"Create note failed: {create_response.text}\"\n        create_data = create_response.json()\n        assert \"id\" in create_data, \"Created note response missing 'id'\"\n        note_id = create_data[\"id\"]\n\n        # 2. Retrieve the created note by ID\n        get_response = requests.get(\n            f\"{BASE_URL}/api/notes/{note_id}\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert get_response.status_code == 200, f\"Get note failed: {get_response.text}\"\n        get_data = get_response.json()\n        assert get_data.get(\"title\") == create_payload[\"title\"]\n        assert get_data.get(\"patientName\") == create_payload[\"patientName\"]\n        assert isinstance(get_data.get(\"content\"), dict) and get_data[\"content\"], \"Content missing or invalid\"\n\n        # 3. Update the note\n        update_payload = {\n            \"title\": create_payload[\"title\"] + \" Updated\",\n            \"patientName\": \"John Doe Updated\",\n            \"content\": {\n                \"subjective\": \"Patient complains of mild headache.\",\n                \"objective\": \"Blood pressure slightly elevated.\",\n                \"assessment\": \"Mild tension headache.\",\n                \"plan\": \"Continue rest and hydration, monitor.\"\n            }\n        }\n        update_response = requests.put(\n            f\"{BASE_URL}/api/notes/{note_id}\",\n            json=update_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert update_response.status_code == 200, f\"Update note failed: {update_response.text}\"\n\n        # 4. Retrieve again to verify update\n        get_updated_response = requests.get(\n            f\"{BASE_URL}/api/notes/{note_id}\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert get_updated_response.status_code == 200, f\"Get updated note failed: {get_updated_response.text}\"\n        updated_data = get_updated_response.json()\n        assert updated_data.get(\"title\") == update_payload[\"title\"]\n        assert updated_data.get(\"patientName\") == update_payload[\"patientName\"]\n        assert updated_data.get(\"content\").get(\"subjective\") == update_payload[\"content\"][\"subjective\"]\n\n        # 5. List all notes - confirm the note is present\n        list_response = requests.get(\n            f\"{BASE_URL}/api/notes\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert list_response.status_code == 200, f\"List notes failed: {list_response.text}\"\n        notes_list = list_response.json()\n        assert any(note.get(\"id\") == note_id for note in notes_list), \"Created note not found in notes list\"\n\n    finally:\n        if note_id:\n            delete_response = requests.delete(\n                f\"{BASE_URL}/api/notes/{note_id}\",\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            # Accept 200 or 204 as successful deletion\n            assert delete_response.status_code in (200, 204), f\"Delete note failed: {delete_response.text}\"\n\ntest_verify_medical_notes_crud_operations()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-10T19:02:56.475Z",
    "modified": "2025-09-10T19:04:19.389Z"
  },
  {
    "projectId": "36533163-cb6a-4961-848c-92c17e4210eb",
    "testId": "e123547b-65fe-47d3-9fb4-b692792cf74a",
    "userId": "04680408-90a1-7095-fc0d-c2c13611246e",
    "title": "TC003-verify_note_templates_management",
    "description": "Test the /api/note-templates endpoints for creating, retrieving, updating, deleting, and importing note templates, validating template structure and access control.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5002\"\nTIMEOUT = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n}\n\n# Assume bearer token might be needed; modify or add authentication as required\n# Example: HEADERS[\"Authorization\"] = \"Bearer YOUR_ACCESS_TOKEN\"\n\ndef verify_note_templates_management():\n    template_id = None\n    try:\n        # 1. Create a new note template\n        create_payload = {\n            \"name\": f\"Test Template {uuid.uuid4()}\",\n            \"type\": \"custom\",\n            \"sections\": [\n                {\"title\": \"History\", \"content\": \"Patient history goes here.\"},\n                {\"title\": \"Examination\", \"content\": \"Physical exam details.\"}\n            ]\n        }\n        create_resp = requests.post(f\"{BASE_URL}/api/note-templates\", json=create_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert create_resp.status_code == 200 or create_resp.status_code == 201, f\"Template creation failed: {create_resp.text}\"\n        template = create_resp.json()\n        assert \"id\" in template, \"Response missing template ID after creation\"\n        template_id = template[\"id\"]\n\n        # 2. Retrieve list of note templates and check newly created template presence\n        list_resp = requests.get(f\"{BASE_URL}/api/note-templates\", headers=HEADERS, timeout=TIMEOUT)\n        assert list_resp.status_code == 200, f\"Failed to list note templates: {list_resp.text}\"\n        templates = list_resp.json()\n        assert any(t.get(\"id\") == template_id for t in templates), \"Created template not in listing\"\n\n        # 3. Update the created template's name and sections\n        updated_payload = {\n            \"name\": f\"Updated Test Template {uuid.uuid4()}\",\n            \"type\": \"custom\",\n            \"sections\": [\n                {\"title\": \"Updated History\", \"content\": \"Updated patient history.\"},\n                {\"title\": \"Updated Examination\", \"content\": \"Updated physical exam details.\"},\n                {\"title\": \"New Section\", \"content\": \"Additional notes.\"}\n            ]\n        }\n        update_resp = requests.put(f\"{BASE_URL}/api/note-templates/{template_id}\", json=updated_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert update_resp.status_code == 200, f\"Failed to update template: {update_resp.text}\"\n        updated_template = update_resp.json()\n        assert updated_template.get(\"name\") == updated_payload[\"name\"], \"Template name was not updated\"\n        assert isinstance(updated_template.get(\"sections\"), list) and len(updated_template[\"sections\"]) == 3, \"Template sections were not updated properly\"\n\n    finally:\n        # 4. Delete the created template to clean up\n        if template_id:\n            delete_resp = requests.delete(f\"{BASE_URL}/api/note-templates/{template_id}\", headers=HEADERS, timeout=TIMEOUT)\n            assert delete_resp.status_code == 200 or delete_resp.status_code == 204, f\"Failed to delete template: {delete_resp.text}\"\n\nverify_note_templates_management()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-10T19:02:56.482Z",
    "modified": "2025-09-10T19:04:36.696Z"
  },
  {
    "projectId": "36533163-cb6a-4961-848c-92c17e4210eb",
    "testId": "803a35d2-1f57-4188-a1f8-eac7e6686b34",
    "userId": "04680408-90a1-7095-fc0d-c2c13611246e",
    "title": "TC004-verify_smart_phrases_system_functionality",
    "description": "Test the /api/smart-phrases endpoints for managing smart phrases including creation, retrieval, updating, deletion, and importing by shareable ID with proper authentication.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5002\"\nTIMEOUT = 30\n\n# Assume an environment variable or fixed token for auth; replace with actual token retrieval if needed\nAUTH_TOKEN = \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.fake.token\"  # Placeholder token\n\nHEADERS = {\n    \"Authorization\": AUTH_TOKEN,\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\",\n}\n\ndef verify_smart_phrases_system_functionality():\n    # 1. Create a new smart phrase\n    create_payload = {\n        \"trigger\": \"hx\",\n        \"content\": \"History of present illness\",\n        \"elements\": [\n            {\"type\": \"text\", \"value\": \"History of present illness \"},\n            {\"type\": \"variable\", \"name\": \"detail\", \"options\": [\"mild\", \"moderate\", \"severe\"]}\n        ]\n    }\n    created_id = None\n    try:\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/smart-phrases\",\n            headers=HEADERS,\n            json=create_payload,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201 or create_resp.status_code == 200, f\"Failed to create smart phrase: {create_resp.text}\"\n        created_data = create_resp.json()\n        assert \"id\" in created_data, \"Response missing smart phrase id\"\n        created_id = created_data[\"id\"]\n\n        # 2. Retrieve list of smart phrases and check created phrase presence\n        get_resp = requests.get(\n            f\"{BASE_URL}/api/smart-phrases\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert get_resp.status_code == 200, f\"Failed to get smart phrases: {get_resp.text}\"\n        phrases = get_resp.json()\n        assert any(sp.get(\"id\") == created_id for sp in phrases), \"Created smart phrase not found in list\"\n\n        # 3. Update the created smart phrase\n        update_payload = {\n            \"trigger\": \"hx-updated\",\n            \"content\": \"Updated history of present illness\",\n            \"elements\": [\n                {\"type\": \"text\", \"value\": \"Updated history of present illness \"}\n            ]\n        }\n        update_resp = requests.put(\n            f\"{BASE_URL}/api/smart-phrases/{created_id}\",\n            headers=HEADERS,\n            json=update_payload,\n            timeout=TIMEOUT\n        )\n        assert update_resp.status_code == 200, f\"Failed to update smart phrase: {update_resp.text}\"\n\n        # 4. Retrieve the updated smart phrase by getting list and filtering\n        get_updated_resp = requests.get(\n            f\"{BASE_URL}/api/smart-phrases\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert get_updated_resp.status_code == 200, f\"Failed to get smart phrases post update: {get_updated_resp.text}\"\n        updated_phrases = get_updated_resp.json()\n        updated_phrase = next((sp for sp in updated_phrases if sp.get(\"id\") == created_id), None)\n        assert updated_phrase is not None, \"Updated smart phrase not found\"\n        assert updated_phrase.get(\"trigger\") == \"hx-updated\", \"Trigger not updated correctly\"\n        assert updated_phrase.get(\"content\") == \"Updated history of present illness\", \"Content not updated correctly\"\n\n        # 5. Import smart phrase by shareable ID (simulate by using created_id)\n        import_resp = requests.post(\n            f\"{BASE_URL}/api/smart-phrases/import/{created_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        if import_resp.status_code == 200:\n            imported_data = import_resp.json()\n            assert \"id\" in imported_data, \"Imported phrase response missing id\"\n            # The imported phrase id could be same or different (depending on system), check at least content matches trigger for sanity\n            assert \"trigger\" in imported_data or \"content\" in imported_data, \"Imported phrase missing expected fields\"\n        else:\n            # The server may reject import of non-public or invalid shareable ID\n            assert import_resp.status_code == 404 or import_resp.status_code == 400, f\"Unexpected status code on import: {import_resp.status_code}\"\n            error_resp = import_resp.json()\n            assert \"error\" in error_resp and error_resp[\"error\"] == \"Smart phrase not found or not public\", f\"Unexpected error message: {error_resp}\"\n\n        # 6. Delete the created smart phrase\n        delete_resp = requests.delete(\n            f\"{BASE_URL}/api/smart-phrases/{created_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert delete_resp.status_code == 200 or delete_resp.status_code == 204, f\"Failed to delete smart phrase: {delete_resp.text}\"\n\n        # 7. Confirm deletion by attempting to get the phrase in list\n        get_final_resp = requests.get(\n            f\"{BASE_URL}/api/smart-phrases\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert get_final_resp.status_code == 200, f\"Failed to get smart phrases after deletion: {get_final_resp.text}\"\n        final_phrases = get_final_resp.json()\n        assert not any(sp.get(\"id\") == created_id for sp in final_phrases), \"Deleted smart phrase still present in list\"\n\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {str(e)}\"\n    except AssertionError:\n        raise\n    except Exception as e:\n        assert False, f\"Unexpected error: {str(e)}\"\n\nverify_smart_phrases_system_functionality()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-10T19:02:56.489Z",
    "modified": "2025-09-10T19:04:53.528Z"
  },
  {
    "projectId": "36533163-cb6a-4961-848c-92c17e4210eb",
    "testId": "253f3340-371c-45c9-969b-2b25be371b87",
    "userId": "04680408-90a1-7095-fc0d-c2c13611246e",
    "title": "TC005-verify_ai_medical_processing_endpoints",
    "description": "Test the AI processing endpoints /api/ai/medications, /api/ai/labs, and /api/ai/pmh to ensure correct processing of input text and appropriate AI-generated responses.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5002\"\nTIMEOUT_SECONDS = 30\n\n\ndef test_verify_ai_medical_processing_endpoints():\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": \"Bearer test-token\"\n    }\n\n    endpoints = [\n        \"/api/ai/medications\",\n        \"/api/ai/labs\",\n        \"/api/ai/pmh\"\n    ]\n\n    test_text = \"Patient reports taking aspirin 81 mg daily and recently had a CBC lab test with abnormal results. Past history includes hypertension and diabetes mellitus type 2.\"\n\n    for endpoint in endpoints:\n        url = f\"{BASE_URL}{endpoint}\"\n        response = requests.post(url, json={\"text\": test_text}, headers=headers, timeout=TIMEOUT_SECONDS)\n        try:\n            response.raise_for_status()\n        except requests.exceptions.RequestException as e:\n            assert False, f\"Request to {endpoint} failed with exception: {e}\"\n        try:\n            json_response = response.json()\n        except ValueError:\n            assert False, f\"Response from {endpoint} is not valid JSON.\"\n\n        assert isinstance(json_response, dict), f\"Response from {endpoint} is not a JSON object.\"\n        assert len(json_response) > 0, f\"Response from {endpoint} is empty.\"\n\n\ntest_verify_ai_medical_processing_endpoints()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 25, in test_verify_ai_medical_processing_endpoints\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 400 Client Error: Bad Request for url: http://localhost:5002/api/ai/medications\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 37, in <module>\n  File \"<string>\", line 27, in test_verify_ai_medical_processing_endpoints\nAssertionError: Request to /api/ai/medications failed with exception: 400 Client Error: Bad Request for url: http://localhost:5002/api/ai/medications\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-10T19:02:56.497Z",
    "modified": "2025-09-10T19:04:33.560Z"
  },
  {
    "projectId": "36533163-cb6a-4961-848c-92c17e4210eb",
    "testId": "0ac36b8f-482e-461c-8a47-86d9ab3aa428",
    "userId": "04680408-90a1-7095-fc0d-c2c13611246e",
    "title": "TC006-verify_run_list_management_workflows",
    "description": "Test the run list management endpoints including retrieving today's run list, adding patients, reordering patients, updating patient info, archiving patients, updating notes, and AI note generation.",
    "code": "import requests\nimport datetime\nimport time\n\nBASE_URL = \"http://localhost:5002\"\nTIMEOUT = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    # Add Authorization header or other headers if authentication is needed\n}\n\ndef test_verify_run_list_management_workflows():\n    # Step 1: Retrieve today's run list (should exist or create one)\n    day_str = datetime.date.today().isoformat()\n    params = {\"day\": day_str, \"carryForward\": True}\n    r = requests.get(f\"{BASE_URL}/api/run-list/today\", params=params, headers=HEADERS, timeout=TIMEOUT)\n    assert r.status_code == 200, \"Failed to get today's run list\"\n    run_lists = r.json()\n    # Assuming run_lists is a list or dict; we need an ID to work with\n    if isinstance(run_lists, dict) and \"id\" in run_lists:\n        run_list = run_lists\n    elif isinstance(run_lists, list) and len(run_lists) > 0:\n        run_list = run_lists[0]\n    else:\n        # Fail here as we need run list\n        assert False, \"No run list available for today or run list missing required id\"\n\n    run_list_id = run_list.get(\"id\") or run_list.get(\"runListId\")\n    assert run_list_id is not None, \"Run list ID is missing\"\n\n    # Store patient IDs for cleanup\n    added_patient_ids = []\n\n    try:\n        # Step 2: Add a patient to the run list\n        add_payload = {\"alias\": \"John Doe\"}\n        r = requests.post(f\"{BASE_URL}/api/run-list/{run_list_id}/patients\", headers=HEADERS, json=add_payload, timeout=TIMEOUT)\n        assert r.status_code in (200, 201), \"Failed to add patient to run list\"\n        patient = r.json()\n        patient_id = patient.get(\"id\") or patient.get(\"patientId\") or patient.get(\"runListPatientId\")\n        assert patient_id is not None, \"Added patient ID missing\"\n        added_patient_ids.append(patient_id)\n\n        # Step 3: Reorder patients in the run list (assuming the run list has at least this one patient)\n        r = requests.get(f\"{BASE_URL}/api/run-list/today\", params=params, headers=HEADERS, timeout=TIMEOUT)\n        assert r.status_code == 200, \"Failed to get today's run list for reordering\"\n        current_run_list = r.json()\n        patients = []\n        if isinstance(current_run_list, dict):\n            patients = current_run_list.get(\"patients\", [])\n        elif isinstance(current_run_list, list) and len(current_run_list) > 0:\n            patients = current_run_list[0].get(\"patients\", [])\n        patient_ids_order = [p.get(\"id\") or p.get(\"patientId\") or p.get(\"runListPatientId\") for p in patients]\n        reordered = list(reversed(patient_ids_order))\n        reorder_payload = {\"order\": reordered}\n        r = requests.put(f\"{BASE_URL}/api/run-list/{run_list_id}/patients/reorder\", headers=HEADERS, json=reorder_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, \"Failed to reorder patients\"\n\n        # Step 4: Update patient info in the run list\n        update_payload = {\"alias\": \"Johnathan Doe\"}\n        r = requests.put(f\"{BASE_URL}/api/run-list/patients/{patient_id}\", headers=HEADERS, json=update_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, \"Failed to update patient info\"\n\n        # Step 5: Update notes for this patient in run list\n        note_update_payload = {\"note\": \"Initial assessment completed.\"}\n        r = requests.put(f\"{BASE_URL}/api/run-list/notes/{patient_id}\", headers=HEADERS, json=note_update_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, \"Failed to update run list note\"\n\n        # Step 6: Generate AI note for this patient\n        ai_payload = {\n            \"listPatientId\": patient_id,\n            \"transcript\": \"Patient is recovering well with no new symptoms.\",\n            \"mode\": \"progress\"\n        }\n        r = requests.post(f\"{BASE_URL}/api/run-list/ai/generate\", headers=HEADERS, json=ai_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, \"Failed to generate AI note\"\n        ai_response = r.json()\n        assert \"note\" in ai_response, \"AI note generation response invalid\"\n\n        # Step 7: Archive patient from run list\n        r = requests.delete(f\"{BASE_URL}/api/run-list/patients/{patient_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert r.status_code == 200, \"Failed to archive patient\"\n        added_patient_ids.remove(patient_id)\n\n    finally:\n        # Cleanup: remove any added patients that were not archived\n        for pid in added_patient_ids:\n            try:\n                requests.delete(f\"{BASE_URL}/api/run-list/patients/{pid}\", headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_verify_run_list_management_workflows()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 93, in <module>\n  File \"<string>\", line 26, in test_verify_run_list_management_workflows\nAssertionError: No run list available for today or run list missing required id\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-10T19:02:56.503Z",
    "modified": "2025-09-10T19:05:11.367Z"
  },
  {
    "projectId": "36533163-cb6a-4961-848c-92c17e4210eb",
    "testId": "bf95454d-d65e-4ccf-b836-c43aa1281d71",
    "userId": "04680408-90a1-7095-fc0d-c2c13611246e",
    "title": "TC007-verify_team_collaboration_features",
    "description": "Test the team collaboration endpoints for creating teams, joining by code, managing todos, and calendar events to ensure multi-user collaboration functionality.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5002\"\nTIMEOUT = 30\nAUTH_TOKEN = None  # Set this to a valid Bearer token if required by the API\n\n\ndef get_headers():\n    headers = {\n        \"Content-Type\": \"application/json\",\n    }\n    if AUTH_TOKEN:\n        headers[\"Authorization\"] = f\"Bearer {AUTH_TOKEN}\"\n    return headers\n\n\ndef test_verify_team_collaboration_features():\n    assert AUTH_TOKEN, \"AUTH_TOKEN must be set to run this test\"\n\n    # We'll create a team, join it by code, create todo and calendar event, then clean up.\n    team_id = None\n    joined_team_id = None\n    todo_id = None\n    calendar_event_id = None\n\n    try:\n        # 1. Create a new team\n        team_name = f\"Test Team {uuid.uuid4()}\"\n        team_desc = \"Test team description\"\n        resp = requests.post(\n            f\"{BASE_URL}/api/teams\",\n            headers=get_headers(),\n            json={\"name\": team_name, \"description\": team_desc},\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 201, f\"Failed to create team: {resp.text}\"\n        team_data = resp.json()\n        team_id = team_data.get(\"id\")\n        group_code = team_data.get(\"groupCode\") or team_data.get(\"code\")\n        assert team_id, \"Team ID missing in create response\"\n        assert group_code and isinstance(group_code, str), \"Group code missing or invalid\"\n\n        # 2. Join the team by code\n        join_resp = requests.post(\n            f\"{BASE_URL}/api/teams/join\",\n            headers=get_headers(),\n            json={\"groupCode\": group_code},\n            timeout=TIMEOUT,\n        )\n        assert join_resp.status_code == 200, f\"Failed to join team: {join_resp.text}\"\n        join_data = join_resp.json()\n        joined_team_id = join_data.get(\"id\") or team_id\n        assert joined_team_id == team_id, \"Joined team ID does not match created team ID\"\n\n        # 3. Create a team todo\n        todo_payload = {\n            \"title\": \"Test Todo\",\n            \"description\": \"This is a test todo item for team collaboration\"\n        }\n        todo_resp = requests.post(\n            f\"{BASE_URL}/api/teams/{team_id}/todos\",\n            headers=get_headers(),\n            json=todo_payload,\n            timeout=TIMEOUT,\n        )\n        assert todo_resp.status_code == 201, f\"Failed to create team todo: {todo_resp.text}\"\n        todo_data = todo_resp.json()\n        todo_id = todo_data.get(\"id\")\n        assert todo_id, \"Todo ID missing in create response\"\n        assert todo_data.get(\"title\") == todo_payload[\"title\"], \"Todo title mismatch\"\n        assert todo_data.get(\"description\") == todo_payload[\"description\"], \"Todo description mismatch\"\n\n        # 4. Retrieve team todos and verify new todo is listed\n        get_todos_resp = requests.get(\n            f\"{BASE_URL}/api/teams/{team_id}/todos\",\n            headers=get_headers(),\n            timeout=TIMEOUT,\n        )\n        assert get_todos_resp.status_code == 200, f\"Failed to get team todos: {get_todos_resp.text}\"\n        todos_list = get_todos_resp.json()\n        assert any(t.get(\"id\") == todo_id for t in todos_list), \"Created todo not found in todo list\"\n\n        # 5. Create a calendar event\n        calendar_payload = {\n            \"title\": \"Test Event\",\n            \"description\": \"Team collaboration test calendar event\",\n            \"startTime\": \"2025-12-01T10:00:00Z\",\n            \"endTime\": \"2025-12-01T11:00:00Z\"\n        }\n        calendar_resp = requests.post(\n            f\"{BASE_URL}/api/teams/{team_id}/calendar\",\n            headers=get_headers(),\n            json=calendar_payload,\n            timeout=TIMEOUT,\n        )\n        assert calendar_resp.status_code == 201, f\"Failed to create calendar event: {calendar_resp.text}\"\n        calendar_data = calendar_resp.json()\n        calendar_event_id = calendar_data.get(\"id\")\n        assert calendar_event_id, \"Calendar event ID missing in create response\"\n        assert calendar_data.get(\"title\") == calendar_payload[\"title\"], \"Calendar event title mismatch\"\n        assert calendar_data.get(\"description\") == calendar_payload[\"description\"], \"Calendar event description mismatch\"\n\n        # 6. Retrieve calendar events and verify new event is listed\n        get_calendar_resp = requests.get(\n            f\"{BASE_URL}/api/teams/{team_id}/calendar\",\n            headers=get_headers(),\n            timeout=TIMEOUT,\n        )\n        assert get_calendar_resp.status_code == 200, f\"Failed to get calendar events: {get_calendar_resp.text}\"\n        events_list = get_calendar_resp.json()\n        assert any(e.get(\"id\") == calendar_event_id for e in events_list), \"Created calendar event not found in event list\"\n\n    finally:\n        # Cleanup: Delete created todo, calendar event, and team if possible\n        if todo_id:\n            try:\n                # Assuming DELETE endpoint /api/teams/{teamId}/todos/{todoId} exists\n                requests.delete(\n                    f\"{BASE_URL}/api/teams/{team_id}/todos/{todo_id}\",\n                    headers=get_headers(),\n                    timeout=TIMEOUT,\n                )\n            except Exception:\n                pass\n        if calendar_event_id:\n            try:\n                # Assuming DELETE endpoint /api/teams/{teamId}/calendar/{eventId} exists\n                requests.delete(\n                    f\"{BASE_URL}/api/teams/{team_id}/calendar/{calendar_event_id}\",\n                    headers=get_headers(),\n                    timeout=TIMEOUT,\n                )\n            except Exception:\n                pass\n        if team_id:\n            try:\n                # Assuming DELETE endpoint /api/teams/{teamId} exists\n                requests.delete(\n                    f\"{BASE_URL}/api/teams/{team_id}\",\n                    headers=get_headers(),\n                    timeout=TIMEOUT,\n                )\n            except Exception:\n                pass\n\n\ntest_verify_team_collaboration_features()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 148, in <module>\n  File \"<string>\", line 19, in test_verify_team_collaboration_features\nAssertionError: AUTH_TOKEN must be set to run this test\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-10T19:02:56.512Z",
    "modified": "2025-09-10T19:05:15.866Z"
  },
  {
    "projectId": "36533163-cb6a-4961-848c-92c17e4210eb",
    "testId": "d17a485e-08c7-4796-95aa-54dc2c22cc31",
    "userId": "04680408-90a1-7095-fc0d-c2c13611246e",
    "title": "TC008-verify_autocomplete_system_endpoints",
    "description": "Test the autocomplete items endpoints for creating, retrieving, updating, and deleting autocomplete entries with category and search filters.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5002\"\nTIMEOUT = 30\n\n# Assuming bearer token auth is required; set your token here if needed\nAUTH_TOKEN = \"\"  # Example: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n}\nif AUTH_TOKEN:\n    HEADERS[\"Authorization\"] = f\"Bearer {AUTH_TOKEN}\"\n\n\ndef test_verify_autocomplete_system_endpoints():\n    created_id = None\n    try:\n        # Step 1: Create autocomplete entry\n        create_payload = {\n            \"text\": f\"test-autocomplete-text-{uuid.uuid4()}\",\n            \"category\": \"medication\",\n            \"dosage\": \"10mg\",\n            \"frequency\": \"once daily\"\n        }\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/autocomplete-items\",\n            json=create_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert create_resp.status_code == 201 or create_resp.status_code == 200, f\"Creation failed: {create_resp.status_code} {create_resp.text}\"\n        create_data = create_resp.json()\n        created_id = create_data.get(\"id\")\n        assert created_id, \"Created autocomplete item ID missing\"\n\n        # Verify the returned created item's category matches expected\n        created_category = create_data.get(\"category\")\n        assert created_category == create_payload[\"category\"], f\"Created category mismatch: expected {create_payload['category']}, got {created_category}\"\n\n        # Step 2: Retrieve autocomplete items with category filter\n        params = {\"category\": \"medication\"}\n        get_resp_cat = requests.get(\n            f\"{BASE_URL}/api/autocomplete-items\",\n            headers=HEADERS,\n            params=params,\n            timeout=TIMEOUT,\n        )\n        assert get_resp_cat.status_code == 200, f\"Get with category filter failed: {get_resp_cat.status_code} {get_resp_cat.text}\"\n        items_cat = get_resp_cat.json()\n        assert isinstance(items_cat, list), \"Get response for category filter is not a list\"\n        # Ensure that created item with matching category is present\n        found = False\n        for item in items_cat:\n            if item.get(\"id\") == created_id and item.get(\"category\") == create_payload[\"category\"]:\n                found = True\n                break\n        assert found, \"Created item missing in filtered category results\"\n\n        # Step 3: Retrieve autocomplete items with search filter\n        search_term = create_payload[\"text\"].split(\"-\")[-1]  # use UUID part as search\n        params_search = {\"search\": search_term}\n        get_resp_search = requests.get(\n            f\"{BASE_URL}/api/autocomplete-items\",\n            headers=HEADERS,\n            params=params_search,\n            timeout=TIMEOUT,\n        )\n        assert get_resp_search.status_code == 200, f\"Get with search filter failed: {get_resp_search.status_code} {get_resp_search.text}\"\n        items_search = get_resp_search.json()\n        assert isinstance(items_search, list), \"Get response for search filter is not a list\"\n        assert any(item.get(\"id\") == created_id for item in items_search), \"Created item missing in search results\"\n\n        # Step 4: Update the created autocomplete item\n        update_payload = {\n            \"text\": create_payload[\"text\"] + \"-updated\",\n            \"category\": \"medication-updated\",\n            \"dosage\": \"20mg\",\n            \"frequency\": \"twice daily\"\n        }\n        update_resp = requests.put(\n            f\"{BASE_URL}/api/autocomplete-items/{created_id}\",\n            json=update_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert update_resp.status_code == 200, f\"Update failed: {update_resp.status_code} {update_resp.text}\"\n\n        # Verify update by retrieving filtered by updated category\n        params_updated_cat = {\"category\": \"medication-updated\"}\n        get_resp_updated_cat = requests.get(\n            f\"{BASE_URL}/api/autocomplete-items\",\n            headers=HEADERS,\n            params=params_updated_cat,\n            timeout=TIMEOUT,\n        )\n        assert get_resp_updated_cat.status_code == 200, f\"Get after update failed: {get_resp_updated_cat.status_code} {get_resp_updated_cat.text}\"\n        items_updated_cat = get_resp_updated_cat.json()\n        assert isinstance(items_updated_cat, list), \"Get response after update is not a list\"\n        assert any(item.get(\"id\") == created_id and item.get(\"text\") == update_payload[\"text\"] for item in items_updated_cat), \"Updated item missing or incorrect after update\"\n\n    finally:\n        # Clean up: Delete the created autocomplete entry if exists\n        if created_id:\n            del_resp = requests.delete(\n                f\"{BASE_URL}/api/autocomplete-items/{created_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT,\n            )\n            assert del_resp.status_code == 200 or del_resp.status_code == 204, f\"Delete failed: {del_resp.status_code} {del_resp.text}\"\n\n\ntest_verify_autocomplete_system_endpoints()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 113, in <module>\n  File \"<string>\", line 58, in test_verify_autocomplete_system_endpoints\nAssertionError: Created item missing in filtered category results\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-10T19:02:56.519Z",
    "modified": "2025-09-10T19:05:19.074Z"
  },
  {
    "projectId": "36533163-cb6a-4961-848c-92c17e4210eb",
    "testId": "e77cdee4-89bf-4339-8141-2ad96426ee3d",
    "userId": "04680408-90a1-7095-fc0d-c2c13611246e",
    "title": "TC009-verify_user_preferences_and_settings_initialization",
    "description": "Test the /api/init endpoint to ensure user preferences and settings are initialized correctly with proper authentication and default values.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5002\"\nTIMEOUT = 30\n\ndef get_auth_token():\n    # For testing purpose, this function should be modified to obtain a valid bearer token.\n    # Placeholder token for illustration, replace with valid token retrieval logic.\n    return \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.testtoken\"\n\ndef test_verify_user_preferences_and_settings_initialization():\n    url = f\"{BASE_URL}/api/init\"\n    headers = {\n        \"Authorization\": get_auth_token(),\n        \"Accept\": \"application/json\",\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to /api/init failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected HTTP 200 OK but got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate expected keys and default values in the response according to typical user preferences and settings\n    expected_keys = [\"uiLayout\", \"language\", \"voiceSettings\", \"specialtyConfig\"]\n    for key in expected_keys:\n        assert key in data, f\"Missing expected key in response: {key}\"\n\n    # Check uiLayout default (example defaults, adjust as per real schema if known)\n    ui_layout = data.get(\"uiLayout\")\n    assert isinstance(ui_layout, dict), \"uiLayout should be an object\"\n    assert \"theme\" in ui_layout, \"uiLayout missing 'theme'\"\n    assert ui_layout.get(\"theme\") in (\"light\", \"dark\"), \"uiLayout.theme should be 'light' or 'dark'\"\n\n    # Check language default\n    language = data.get(\"language\")\n    assert isinstance(language, str) and len(language) > 0, \"language should be a non-empty string\"\n\n    # Check voiceSettings presence and structure\n    voice_settings = data.get(\"voiceSettings\")\n    assert isinstance(voice_settings, dict), \"voiceSettings should be an object\"\n    # Example keys for voice settings (can be adapted)\n    voice_keys = [\"enabled\", \"voiceType\", \"speechRate\"]\n    for vk in voice_keys:\n        assert vk in voice_settings, f\"voiceSettings missing key: {vk}\"\n\n    # Check specialtyConfig presence and typical structure\n    specialty_config = data.get(\"specialtyConfig\")\n    assert isinstance(specialty_config, dict), \"specialtyConfig should be an object\"\n\ntest_verify_user_preferences_and_settings_initialization()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 55, in <module>\n  File \"<string>\", line 22, in test_verify_user_preferences_and_settings_initialization\nAssertionError: Expected HTTP 200 OK but got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-10T19:02:56.526Z",
    "modified": "2025-09-10T19:04:37.489Z"
  },
  {
    "projectId": "36533163-cb6a-4961-848c-92c17e4210eb",
    "testId": "d7ff68a4-a942-42d5-a51c-d81b9b716eb6",
    "userId": "04680408-90a1-7095-fc0d-c2c13611246e",
    "title": "TC010-verify_lab_settings_and_presets_management",
    "description": "Test the lab settings and presets endpoints for retrieving, updating, resetting user lab settings, and managing lab presets including creation, update, and deletion.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5002\"\nTIMEOUT = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    # Add Authentication header if required, e.g. \"Authorization\": f\"Bearer {token}\"\n}\n\n\ndef test_verify_lab_settings_and_presets_management():\n    session = requests.Session()\n    session.headers.update(HEADERS)\n\n    lab_preset_id = None\n    try:\n        # 1. Get current user lab settings\n        resp = session.get(f\"{BASE_URL}/api/user-lab-settings\", timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Get lab settings failed: {resp.text}\"\n        original_lab_settings = resp.json()\n\n        # 2. Update lab settings - send original settings back as payload (not empty)\n        update_payload = original_lab_settings if original_lab_settings else {\"dummy\": \"value\"}\n        resp = session.post(f\"{BASE_URL}/api/user-lab-settings\", json=update_payload, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Update lab settings failed: {resp.text}\"\n\n        # 3. Reset lab settings\n        resp = session.delete(f\"{BASE_URL}/api/user-lab-settings\", timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Reset lab settings failed: {resp.text}\"\n\n        # 4. Get lab presets\n        resp = session.get(f\"{BASE_URL}/api/lab-presets\", timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Get lab presets failed: {resp.text}\"\n        presets = resp.json()\n        assert isinstance(presets, list), \"Lab presets response not a list\"\n\n        # 5. Create a new lab preset\n        new_preset_data = {\n            \"name\": f\"TestPreset_{uuid.uuid4().hex[:8]}\",\n            \"config\": {\"visibility\": \"all\", \"trending\": True},  # Assuming possible config structure\n        }\n        # The PRD doesn't specify schema for lab preset creation; minimal valid example:\n        # We'll send name only, assume server accepts extra fields or minimal name only.\n        resp = session.post(f\"{BASE_URL}/api/lab-presets\", json={\"name\": new_preset_data[\"name\"]}, timeout=TIMEOUT)\n        assert resp.status_code == 201 or resp.status_code == 200, f\"Create lab preset failed: {resp.text}\"\n        created_preset = resp.json()\n        lab_preset_id = created_preset.get(\"id\")\n        assert lab_preset_id is not None, \"Created lab preset missing id\"\n\n        # 6. Update the created lab preset\n        update_preset_payload = {\"name\": new_preset_data[\"name\"] + \"_Updated\"}\n        resp = session.put(f\"{BASE_URL}/api/lab-presets/{lab_preset_id}\", json=update_preset_payload, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Update lab preset failed: {resp.text}\"\n        updated_preset = resp.json()\n        assert updated_preset.get(\"name\") == update_preset_payload[\"name\"], \"Lab preset name not updated\"\n\n        # 7. Delete the created lab preset\n        resp = session.delete(f\"{BASE_URL}/api/lab-presets/{lab_preset_id}\", timeout=TIMEOUT)\n        assert resp.status_code == 200 or resp.status_code == 204, f\"Delete lab preset failed: {resp.text}\"\n        lab_preset_id = None\n\n    finally:\n        # Cleanup in case preset was created but not deleted\n        if lab_preset_id is not None:\n            try:\n                session.delete(f\"{BASE_URL}/api/lab-presets/{lab_preset_id}\", timeout=TIMEOUT)\n            except Exception:\n                pass\n\n\ntest_verify_lab_settings_and_presets_management()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 72, in <module>\n  File \"<string>\", line 26, in test_verify_lab_settings_and_presets_management\nAssertionError: Update lab settings failed: {\"message\":\"Failed to save lab setting\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-10T19:02:56.534Z",
    "modified": "2025-09-10T19:05:14.844Z"
  }
]
